#!/usr/bin/env python
"""
build.py - Asset bundler for Prompter application

This script bundles all JavaScript files into a single minified file (static/js/main.js)
and all CSS files into a single minified file (static/css/main.css).
It searches recursively through all directories, ignoring only specific directories.
"""

import os
import jsmin
import re
from pathlib import Path

# Directories to exclude from file search
EXCLUDED_DIRS = [
    'venv', '.venv', 'env', '.env',  # Virtual environments
    'node_modules',                  # Node.js modules
    '__pycache__',                   # Python cache
    '.git', '.svn',                  # Version control
    'dist', 'build',                 # Build directories
    'migrations',                    # Database migrations
    '.idea', '.vscode',              # IDE directories
]


def find_files(root_dir, extension, exclude_files=None):
    """
    Find all files with a specific extension in the project

    Args:
        root_dir (Path): Root directory to search
        extension (str): File extension to find (e.g., '.js', '.css')
        exclude_files (list): Specific files to exclude

    Returns:
        list: List of Path objects for matching files
    """
    if exclude_files is None:
        exclude_files = []

    matching_files = []

    for path in root_dir.rglob(f'*{extension}'):
        # Skip files in excluded directories
        if any(excluded in path.parts for excluded in EXCLUDED_DIRS):
            continue

        # Skip specifically excluded files
        if path.name in exclude_files:
            continue

        matching_files.append(path)

    return sorted(matching_files)


def bundle_js():
    """Bundle all JavaScript files into a single minified file at static/js/main.js"""

    print("\n=== JavaScript Bundling ===")

    # Define paths
    root_dir = Path(__file__).resolve().parent
    output_dir = root_dir / 'static' / 'build' / 'js'
    output_file = output_dir / 'main.js'

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Find all JS files, excluding main.js
    js_files = find_files(root_dir, '.js', exclude_files=['main.js'])

    if not js_files:
        print("No JavaScript files found!")
        return

    print(f"Found {len(js_files)} JavaScript files to bundle")

    # Start building the bundle
    bundled_js = [
        "/**",
        " * Prompter Application - Bundled JavaScript",
        " * Generated by build.py",
        " */",
        ""
    ]

    # Process each file
    total_size = 0
    for js_file in js_files:
        relative_path = js_file.relative_to(root_dir)
        print(f"Adding: {relative_path}")

        with open(js_file, 'r', encoding='utf-8') as f:
            content = f.read()
            file_size = len(content)
            total_size += file_size

            # Add file header comment and content
            bundled_js.append(f"/* File: {relative_path} */")
            bundled_js.append(content)
            bundled_js.append("\n")  # Add separator between files

    # Join all content
    combined_js = "\n".join(bundled_js)

    # Minify JavaScript
    print("Minifying JavaScript...")
    minified_js = jsmin.jsmin(combined_js)

    # Write output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(minified_js)

    # Calculate size reduction
    original_size = len(combined_js)
    minified_size = len(minified_js)
    reduction_percent = (1 - minified_size / original_size) * \
        100 if original_size > 0 else 0

    print(f"Successfully created bundle: {output_file}")
    print(f"Original size: {original_size:,} bytes")
    print(f"Minified size: {minified_size:,} bytes")
    print(f"Size reduction: {reduction_percent:.1f}%")

    return output_file


def minify_css(css_content):
    """Simple CSS minification function"""
    # Remove comments
    css_content = re.sub(r'/\*[\s\S]*?\*/', '', css_content)
    # Remove whitespace
    css_content = re.sub(r'\s+', ' ', css_content)
    # Remove spaces after colons, commas, etc.
    css_content = re.sub(r':\s', ':', css_content)
    css_content = re.sub(r',\s', ',', css_content)
    css_content = re.sub(r'{\s', '{', css_content)
    css_content = re.sub(r';\s', ';', css_content)
    css_content = re.sub(r'\s}', '}', css_content)
    # Remove trailing semicolons
    css_content = re.sub(r';}', '}', css_content)
    # Remove leading/trailing whitespace
    css_content = css_content.strip()
    return css_content


def bundle_css():
    """Bundle all CSS files into a single minified file at static/css/main.css"""

    print("\n=== CSS Bundling ===")

    # Define paths
    root_dir = Path(__file__).resolve().parent
    output_dir = root_dir / 'static' / 'build' / 'css'
    output_file = output_dir / 'main.css'

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Check for CSS files in the static directory's style tag
    style_in_html = extract_inline_styles(root_dir / 'templates' / 'main.html')

    # Get list of CSS files to bundle - exclude main.css itself
    css_files = find_files(root_dir, '.css', exclude_files=['main.css'])

    if not css_files and not style_in_html:
        print("No CSS files or inline styles found!")
        return

    print(f"Found {len(css_files)} CSS files to bundle")
    if style_in_html:
        print("Found inline styles in main.html")

    # Start building the bundle
    bundled_css = [
        "/**",
        " * Prompter Application - Bundled CSS",
        " * Generated by build.py",
        " */",
        ""
    ]

    # Process each file
    total_size = 0
    for css_file in css_files:
        relative_path = css_file.relative_to(root_dir)
        print(f"Adding: {relative_path}")

        with open(css_file, 'r', encoding='utf-8') as f:
            content = f.read()
            file_size = len(content)
            total_size += file_size

            # Add file header comment and content
            bundled_css.append(f"/* File: {relative_path} */")
            bundled_css.append(content)
            bundled_css.append("\n")  # Add separator between files

    # Add inline styles if found
    if style_in_html:
        bundled_css.append("/* Inline styles from main.html */")
        bundled_css.append(style_in_html)
        bundled_css.append("\n")
        total_size += len(style_in_html)

    # Join all content
    combined_css = "\n".join(bundled_css)

    # Minify CSS
    print("Minifying CSS...")
    minified_css = minify_css(combined_css)

    # Write output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(minified_css)

    # Calculate size reduction
    original_size = len(combined_css)
    minified_size = len(minified_css)
    reduction_percent = (1 - minified_size / original_size) * \
        100 if original_size > 0 else 0

    print(f"Successfully created bundle: {output_file}")
    print(f"Original size: {original_size:,} bytes")
    print(f"Minified size: {minified_size:,} bytes")
    print(f"Size reduction: {reduction_percent:.1f}%")

    return output_file


def extract_inline_styles(html_file_path):
    """Extract inline styles from an HTML file"""
    if not html_file_path.exists():
        return ""

    with open(html_file_path, 'r', encoding='utf-8') as f:
        html_content = f.read()

    # Look for style tags
    style_pattern = re.compile(r'<style>(.*?)</style>', re.DOTALL)
    matches = style_pattern.findall(html_content)

    if not matches:
        return ""

    # Combine all style blocks
    return "\n".join(matches)


def update_html_template():
    """Update the main.html template to use bundled assets"""
    template_path = Path(__file__).resolve().parent / 'templates' / 'main.html'
    if not template_path.exists():
        print("Template file not found: templates/main.html")
        return False

    with open(template_path, 'r', encoding='utf-8') as f:
        html_content = f.read()

    # Check if we need to update the HTML
    js_bundle_reference = '{{ url_for(\'build\', filename=\'js/main.js\') }}'
    css_bundle_reference = '{{ url_for(\'build\', filename=\'css/main.css\') }}'

    needs_js_update = js_bundle_reference not in html_content
    needs_css_update = css_bundle_reference not in html_content and '<style>' in html_content

    if not needs_js_update and not needs_css_update:
        print("\nMain HTML template already uses bundled assets.")
        return False

    print("\n=== Updating HTML Template ===")

    # Update JavaScript references
    if needs_js_update:
        # Find all script tags referencing JS files
        script_pattern = r'<script src="\{\{ url_for\((\'static\'|\'build\'), filename=\'js/[^\']*\.js\'\) \}\}"[^>]*></script>'
        script_tags = re.findall(script_pattern, html_content)

        if script_tags:
            # Replace multiple script tags with a single bundled reference
            bundled_script_tag = f'<script src="{js_bundle_reference}"></script>'

            # Replace the block of script tags
            # First, find the Application Scripts comment if it exists
            script_block_start = html_content.find(
                '<!-- Application Scripts -->')
            if script_block_start > -1:
                # Find the end of the script block
                script_block_end = html_content.find(
                    '</script>', script_block_start)
                if script_block_end > -1:
                    script_block_end += 9  # Include the </script> tag

                    # Extract the original block
                    original_block = html_content[script_block_start:script_block_end]

                    # Create new block with just the bundled script
                    new_block = f'<!-- Application Scripts -->\n    {bundled_script_tag}'

                    # Replace in HTML
                    html_content = html_content.replace(
                        original_block, new_block)
                    print("Updated JavaScript references in template")
            else:
                # If no comment block, just replace the first script with bundled and remove others
                first_script = script_tags[0]
                html_content = html_content.replace(
                    first_script, bundled_script_tag)

                for tag in script_tags[1:]:
                    html_content = html_content.replace(tag, '')

                print("Updated JavaScript references in template")

    # Update CSS references and remove inline styles if they exist
    if needs_css_update:
        # Check for inline styles
        style_tag_pattern = r'<style>(.*?)</style>'
        style_tags = re.findall(style_tag_pattern, html_content, re.DOTALL)

        if style_tags:
            # Create CSS link tag
            css_link_tag = f'<link rel="stylesheet" href="{css_bundle_reference}" />'

            # Find where to insert the CSS link (before the closing head tag)
            head_close_pos = html_content.find('</head>')
            if head_close_pos > -1:
                # Insert before </head>
                html_content = html_content[:head_close_pos] + \
                    f'  {css_link_tag}\n  ' + html_content[head_close_pos:]

                # Remove all style tags
                for style_content in style_tags:
                    style_tag = f'<style>{style_content}</style>'
                    html_content = html_content.replace(style_tag, '')

                print("Moved inline styles to external CSS and added link to template")
        else:
            # Look for existing CSS link tags
            link_pattern = r'<link rel="stylesheet" href="\{\{ url_for\((\'static\'|\'build\'), filename=\'css/[^\']*\.css\'\) \}\}"[^>]*>'
            link_tags = re.findall(link_pattern, html_content)

            if link_tags:
                # Replace with bundled CSS link
                css_link_tag = f'<link rel="stylesheet" href="{css_bundle_reference}" />'

                # Replace first link and remove others
                first_link = link_tags[0]
                html_content = html_content.replace(first_link, css_link_tag)

                for tag in link_tags[1:]:
                    html_content = html_content.replace(tag, '')

                print("Updated CSS references in template")
            else:
                # Add new CSS link before closing head
                head_close_pos = html_content.find('</head>')
                if head_close_pos > -1:
                    css_link_tag = f'<link rel="stylesheet" href="{css_bundle_reference}" />'
                    html_content = html_content[:head_close_pos] + \
                        f'  {css_link_tag}\n  ' + html_content[head_close_pos:]
                    print("Added CSS link to template")

    # Write updated template
    with open(template_path, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print("Successfully updated HTML template")
    return True


if __name__ == "__main__":
    print("Starting asset bundling process...")

    # Bundle JavaScript
    bundle_js()

    # Bundle CSS
    bundle_css()

    # Update HTML template
    template_updated = update_html_template()

    if template_updated:
        print("\nBundling complete! The application now uses bundled assets.")
    else:
        print("\nBundling complete! Assets have been bundled but you may need to manually update your HTML templates.")
        print("Add these lines to your template:")
        print(
            '  <link rel="stylesheet" href="{{ url_for(\'build\', filename=\'css/main.css\') }}" />')
        print(
            '  <script src="{{ url_for(\'build\', filename=\'js/main.js\') }}"></script>')
